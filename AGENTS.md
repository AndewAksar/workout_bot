# План рефакторинга бота (для себя)

Цель: провести аккуратный рефакторинг всего кода без изменения бизнес‑логики, привести проект к best practices Python, повысить устойчивость, читаемость и производительность.

Общий подход:
- Минимизировать изменения публичного поведения: сигнатуры обработчиков, тексты сообщений, состояния ConversationHandler — без изменений.
- Точечно улучшать качество кода: стиль импортов, обработка ошибок, работа с БД, неблокирующие IO‑вызовы, единообразное логирование.
- Не менять структуру пакетов радикально (оставить возможность запуска так, как сейчас), но унифицировать импорты внутри кода.

Основные задачи
1) Импорты и структура модулей
   - Везде использовать абсолютные импорты из пакета `bot.*` (убрать смешение `config.*`, `handlers.*`).
   - В `main.py` устранить пересечения имён с встроенными: импортировать обработчики команд под алиасами (`help_command`, `settings_command`).
   - Сохранить текущий `sys.path.append(...)` для обратной совместимости запуска, но отметить как долг техдолга (лучше запускать `python -m bot.main`).

2) Конфигурация и зависимости
   - В `settings.py` централизовать флаги сетевой верификации SSL (например, `VERIFY_SSL` из .env) и использовать в HTTP‑клиенте.
   - Добавить проверку наличия `TELEGRAM_TOKEN` при запуске; при отсутствии — понятная ошибка и завершение.
   - Обновить `requirement.txt`: удалить устаревший `dotenv`, добавить недостающий `requests` (используется в AI API).

3) Работа с SQLite
   - Заменить ручное открытие/закрытие соединений на контекст‑менеджеры `with sqlite3.connect(DB_PATH) as conn:` во всех обработчиках.
   - Избежать множественных `conn.close()` в try/except/finally; отдать управление контекст‑менеджеру.
   - Локальные курсоры называть консистентно (например, `cur`).

4) Обработка ошибок и надёжность
   - Корректно обрабатывать парсинг числовых значений (возраст/вес/рост): отлавливать `ValueError` и отправлять то же сообщение о некорректном вводе без падения.
   - Исправить использование `update.callback_query` в местах, где в обработчике есть только `message` (исключение в `ai_handler.handle_ai_message`).
   - Исправить форматирование логов (например, `logger.error(... e)` → `logger.error(... {e})`).

5) Производительность (async)
   - В `ai_handler.handle_ai_message` вынести синхронный вызов `generate_gigachat_response()` в фоновую нить через `asyncio.to_thread(...)`, чтобы не блокировать event loop.
   - Оставить интерфейс и поведение прежними (тот же текст ответов, та же разбивка на части по 4096 символов).

6) Чистка и мелкие улучшения
   - Удалить неиспользуемые импорты (например, `InlineKeyboard*` в `help_command`).
   - Удалить неиспользуемые переменные (например, временный `db_path` в `set_weight`).
   - Привести лог‑сообщения к единообразному стилю, без избыточностей.
   - Не удалять и не переписывать экспериментальные модули (например, `ai_assistant/open_ai_bot.py`), но не тащить их зависимости в обязательные пути исполнения.

Не вношу (осознанно, чтобы не менять логику/запуск):
- Не убираю `sys.path.append(...)` из `main.py` (оставляю как компромисс для текущего сценария запуска).
- Не меняю тексты сообщений пользователю и CallbackData.
- Не меняю схему БД и названия таблиц/полей.

Валидация после рефакторинга
- Быстрый линт/просмотр на предмет неиспользуемых импортов и опечаток.
- Локальный запуск без токенов: проверка импорта модулей и «сухой» импорт `main.py` (без выполнения рутины polling).
- При наличии токенов и доступа в сеть: пробный запуск, ввод граничных значений в диалогах, проверка AI‑ветки на длинных ответах.

Идеи для будущих улучшений (вне текущего объёма)
- Перейти на явный модульный запуск: `python -m bot.main`, убрать `sys.path`‑хаки.
- Вынести работу с БД в тонкий DAO‑слой, чтобы избежать дублирования запросов.
- Перейти с `requests` на асинхронный клиент (`httpx.AsyncClient`) и полностью асинхронизировать AI‑ветку.
- Добавить mypy/ruff/black конфигурацию и CI‑проверки.
